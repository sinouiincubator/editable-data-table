---
name: 分页展示数据
route: /pagination-show
---

import { Playground } from 'docz';
import Demo from './Demo';

# 分页展示数据的可编辑数据表格

本章节介绍一个场景：一次性加载列表数据，但是在前端分页显示的可编辑数据表格。

包含的功能：

- 分页展示列表
- 加载数据
- 查询
- 新增

```tsx
import React, { useState, useMemo, useCallback } from 'react';
import Pagination from 'sinoui-components/Pagination';
import Button from 'sinoui-components/Button';
import TextInput from 'sinoui-components/TextInput';
import EditableDataTable, {
  useEditingList,
  TableColumn,
  RowSelectColumn,
} from '../src';

interface Article {
  id: string;
  title: string;
}

/**
 * 分页状态hook
 */
function usePagination(
  defaultCurrentPage: number = 0,
  defaultPageSize: number = 10,
): [number, number, (pageNo: number, pageSize: number) => void] {
  const [currentPage, setCurrentPage] = useState(defaultCurrentPage);
  const [pageSize, setPageSize] = useState(defaultPageSize);

  const update = (pageNo: number, newPageSize: number) => {
    setCurrentPage(pageNo);
    setPageSize(newPageSize);
  };

  return [currentPage, pageSize, update];
}

/**
 * 获取分页列表
 *
 * @param items 列表
 * @param currentPage 当前页
 * @param pageSize 页大小
 */
function usePaginationList<T>(
  items: T[],
  currentPage: number,
  pageSize: number,
) {
  const data = useMemo(
    () => items.slice(currentPage * pageSize, (currentPage + 1) * pageSize),
    [items, pageSize, currentPage],
  );

  return data;
}

/**
 * 获取分页编辑列表的动作
 *
 * @param editingList 编辑列表
 * @param currentPage 当前页
 * @param pageSize 页大小
 */
function usePaginationEditingListActions<T>(
  editingList: any,
  currentPage: number,
  pageSize: number,
) {
  const add = useCallback(() => {
    editingList.add({}, currentPage * pageSize);
  }, [currentPage, editingList, pageSize]);

  const save = useCallback(
    (item: T, index: number) => {
      return editingList.save(item, currentPage * pageSize + index);
    },
    [currentPage, editingList, pageSize],
  );

  const edit = useCallback(
    (index: number) => {
      editingList.edit(currentPage * pageSize + index);
    },
    [currentPage, editingList, pageSize],
  );

  const remove = useCallback(
    (item: T, index: number) => {
      return editingList.remove(item, currentPage * pageSize + index);
    },
    [currentPage, editingList, pageSize],
  );

  return { add, save, edit, remove };
}

/**
 * 生成序列数组
 *
 * @param start 开始
 * @param end 结束
 */
function range(start: number, end: number) {
  return new Array(end - start).fill(null).map((_, idx) => start + idx);
}

/**
 * 分页的选中行状态
 *
 * @param editingList 可编辑列表
 * @param currentPage 当前页
 * @param pageSize 页大小
 */
function usePaginationSelectedRows(
  editingList: any,
  currentPage: number,
  pageSize: number,
) {
  const start = currentPage * pageSize;
  const end = Math.min(editingList.items.length, (currentPage + 1) * pageSize);

  /**
   * 当前页的数据行是否全部选中
   */
  const isAllSelected = useMemo(() => {
    return range(start, end).every(
      (idx) => editingList.selectedRows.indexOf(idx) !== -1,
    );
  }, [currentPage, editingList.selectedRows, pageSize]);

  /**
   * 是否包含当前页的选中行
   */
  const isContainsSelected = useMemo(() => {
    return range(start, end).some(
      (idx) => editingList.selectedRows.indexOf(idx) !== -1,
    );
  }, [currentPage, editingList.selectedRows, pageSize]);

  /**
   * 切换当前页的全选
   */
  const toggleAllSelected = useCallback(() => {
    editingList.setRowsSelected(range(start, end), !isAllSelected);
  }, [editingList, end, isAllSelected, start]);

  /**
   * 删除所有选中的数据
   */
  const removeAllSelectedRows = async () => {
    const rows = editingList.items
      .map((item, idx) => [item, idx])
      .filter((_data, index) => editingList.selectedRows.includes(index));
    await editingList.remove(rows);
  };

  return {
    isAllSelected,
    isContainsSelected,
    toggleAllSelected,
    removeAllSelectedRows,
  };
}

function Demo() {
  const editingList = useEditingList<Partial<Article>>(
    '/api/pagination-show-demo',
    [],
  );
  const [currentPage, pageSize, update] = usePagination();
  const data = usePaginationList(editingList.items, currentPage, pageSize);
  const editingRows = usePaginationList(
    editingList.editingRows,
    currentPage,
    pageSize,
  );

  const { add, save, edit, remove } = usePaginationEditingListActions(
    editingList,
    currentPage,
    pageSize,
  );

  const [searchText, setSearchText] = useState('');
  const handleQuery = () => {
    editingList.query({ title: searchText });
  };

  const handleRowClassName = (index: number) => {
    if (editingList.selectedRows.includes(index + currentPage * pageSize)) {
      return 'sinoui-data-table-body-row_selected';
    }

    return '';
  };

  const paginationSelectedRows = usePaginationSelectedRows(
    editingList,
    currentPage,
    pageSize,
  );

  return (
    <div>
      <TextInput
        value={searchText}
        onChange={(event) => setSearchText(event.target.value)}
      />
      <Button raised onClick={handleQuery}>
        查询
      </Button>
      <Button raised onClick={add}>
        新增
      </Button>
      <Button onClick={paginationSelectedRows.removeAllSelectedRows}>
        删除
      </Button>
      <EditableDataTable
        data={data}
        editingRows={editingRows}
        idPropertyName={editingList.idPropertyName}
        rowClassName={handleRowClassName}
      >
        <RowSelectColumn
          startIndex={currentPage * pageSize}
          selectedRows={editingList.selectedRows}
          isAllSelected={paginationSelectedRows.isAllSelected}
          isContainsSelected={paginationSelectedRows.isContainsSelected}
          toggleAllSelected={paginationSelectedRows.toggleAllSelected}
          toggleRowSelected={editingList.toggleRowSelected}
        />
        <TableColumn name="id" title="id" />
        <TableColumn name="title" title="标题" editor="input" />
        <TableColumn
          title="操作"
          name="id"
          render={(_value, item, index, _id, context) => (
            <>
              {context.editing ? (
                <Button autoWidth onClick={() => save(item, index)}>
                  保存
                </Button>
              ) : (
                <Button autoWidth onClick={() => edit(index)}>
                  编辑
                </Button>
              )}
              <Button
                autoWidth
                color="danger"
                onClick={() => remove(item, index)}
              >
                删除
              </Button>
            </>
          )}
        />
      </EditableDataTable>
      <Pagination
        pageSize={pageSize}
        total={editingList.items.length}
        currentPage={currentPage + 1}
        onChange={(pageNo, size) => update(pageNo - 1, size)}
      />
    </div>
  );
}

export default Demo;
```

效果：

<Playground>
  <Demo />
</Playground>

如果你感觉上面的例子有点复杂，可以看看下面的步骤分析：

- [加载并展现列表数据](#加载并展现列表数据)
- [分页展现数据](#分页展现数据)
- [新增数据](#新增数据)
- [编辑与删除数据](#编辑与删除数据)
- [查询列表](#查询列表)
- [选择](#选择)
- [删除选中数据](#删除选中数据)

## 加载并展现列表数据

本例需要一次性加载全部的列表数据，而不是[分页加载数据](/pagination-editable-table)。使用`useEditingList`来加载列表数据。代码如下：

```tsx
import React from 'react';
import EditableDataTable, {
  TableColumn,
  useEditingList,
} from '@sinouiincubator/editable-data-table';

function Demo() {
  const editingList = useEditingList('/api/pagination-show-demo');

  return (
    <EditableDataTable
      data={editingList.items}
      idPropertyName={editingList.idPropertyName}
    >
      <TableColumn title="id" name="id" />
      <TableColumn title="标题" name="title" />
    </EditableDataTable>
  );
}
```

## 分页展现数据

可以使用`sinoui-components/Pagination`组件作为分页器，展现页码信息和切换页码的操作按钮。`Pagination`组件需要以下几个关键属性：

- `total` - 列表数据总数目。
- `currentPage` - 当前页码。从`1`开始。
- `pageSize` - 页大小。一页能够呈现数据的数目。
- `onChange` - 指定当前页码、页大小发生变化的回调函数。

上面三个属性，`total`等于`editingList.items.length`，`currentPage`和`pageSize`是变化的数据，所以需要定义两个状态来维护，如下所示：

```tsx
import React, { useState } from 'react';
import EditableDataTable, {
  TableColumn,
  useEditingList,
} from '@sinouiincubator/editable-data-table';
import Pagination from 'sinoui-components/Pagination';

function Demo() {
  const editingList = useEditingList('/api/pagination-show-demo');
  const [currentPage, setCurrentPage] = useState(0); // 当前页码，习惯从0开始。注意与Pagination.currentPage的区别。
  const [pageSize, setPageSize] = useState(10);

  const handlePaginationChange = (pageNo: number, newPageSize: number) => {
    setCurrentPage(pageNo);
    setPageSize(newPageSize);
  };

  return (
    <div>
      <!--此处省略EditableDataTable-->
      <Pagination
        total={editingList.items.length}
        currentPage={currentPage}
        pageSize={pageSize}
        onChange={handlePaginationChange}
      />
    </div>
  );
}
```

上面的代码只是展现出了分页器，接下来我们来解决分页展现列表数据（注意哟，这个时候列表还是展现所有的数据）。

`EditableDataTable`的`data`属性是用来接收需要展现的一组数据的属性。`data={editingList.items}`会将所有的数据给了可编辑表格呈现出来。现在想要只呈现当前页的数据，那就计算出当前页的数据数组指定给`data`即可，代码如下：

```tsx
import React, { useMemo } from 'react';
// ... 省略一部分import代码

function Demo() {
  // ...省略一部分代码
  const data = useMemo(() =>
    editingList.items.slice(
      currentPage * pageSize,
      (currentPage + 1) * pageSize,
    ),
    [editingList.items, currentPage, pageSize],
  );

  return (
    <div>
      <EditableDataTable data={data}>
        <!--此处省略TableColumn-->
      </EditableDataTable>
      <!--此处省略Pagination-->
    </div>
  );
}
```

这里使用[React useMemo](https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo)缓存了分页数据的计算。

完整代码如下：

```tsx
import React, { useState, useMemo } from 'react';
import EditableDataTable, {
  TableColumn,
  useEditingList,
} from '@sinouiincubator/editable-data-table';
import Pagination from 'sinoui-components/Pagination';

function Demo() {
  const editingList = useEditingList('/api/pagination-show-demo');

  const [currentPage, setCurrentPage] = useState(0); // 当前页码，习惯从0开始。注意与Pagination.currentPage的区别。
  const [pageSize, setPageSize] = useState(10);

  const handlePaginationChange = (pageNo: number, newPageSize: number) => {
    setCurrentPage(pageNo);
    setPageSize(newPageSize);
  };

  const data = useMemo(
    () =>
      editingList.items.slice(
        currentPage * pageSize,
        (currentPage + 1) * pageSize,
      ),
    [editingList.items, currentPage, pageSize],
  );

  return (
    <div>
      <EditableDataTable
        data={data}
        idPropertyName={editingList.idPropertyName}
      >
        <TableColumn title="id" name="id" />
        <TableColumn title="标题" name="title" />
      </EditableDataTable>
      <Pagination
        total={editingList.items.length}
        currentPage={currentPage}
        pageSize={pageSize}
        onChange={handlePaginationChange}
      />
    </div>
  );
}
```

## 提炼状态管理

Demo 组件目前已经比较复杂了，需要管理很多状态，我们可以使用[自定义 hook](https://zh-hans.reactjs.org/docs/hooks-custom.html)将状态管理提炼到更小的函数中进行维护。现在我们来提炼两个自定义 hook，分别是`usePagination`和`usePaginationList`。

我们可以将分页器状态和更新方法迁移到一个自定义 hook 中，我们取名为`usePagination`:

```tsx
/**
 * 分页状态hook
 */
function usePagination(
  defaultCurrentPage: number = 0,
  defaultPageSize: number = 10,
): [number, number, (pageNo: number, pageSize: number) => void] {
  const [currentPage, setCurrentPage] = useState(defaultCurrentPage);
  const [pageSize, setPageSize] = useState(defaultPageSize);

  const update = (pageNo: number, newPageSize: number) => {
    setCurrentPage(pageNo);
    setPageSize(newPageSize);
  };

  return [currentPage, pageSize, update];
}
```

这样 Demo 组件中的分页代码可以简化一下：

```tsx
function Demo() {
  const [currentPage, pageSize, update] = usePagination();

  return (
    <div>
      <Pagination
        total={editingList.items.length}
        currentPage={currentPage}
        pageSize={pageSize}
        onChange={(pageNo, newPageSize) => update(pageNo - 1, newPageSize)}
      />
    </div>
  );
}
```

可以将获取分页的列表数据也提炼到自动以 hook 中，我们取名为`usePaginationList`:

```tsx
/**
 * 获取分页列表
 *
 * @param items 列表
 * @param currentPage 当前页
 * @param pageSize 页大小
 */
function usePaginationList<T>(
  items: T[],
  currentPage: number,
  pageSize: number,
) {
  const data = useMemo(
    () => items.slice(currentPage * pageSize, (currentPage + 1) * pageSize),
    [items, pageSize, currentPage],
  );

  return data;
}
```

Demo 组件可以简化`data`的计算：

```tsx
function Demo() {
  const data = usePaginationList(editingList.items, currentPage, pageSize);

  return (
    <div>
      <EditableDataTable data={data} />
    </div>
  );
}
```

完整的代码如下：

```tsx
import React, { useState, useMemo } from 'react';
import EditableDataTable, {
  TableColumn,
  useEditingList,
} from '@sinouiincubator/editable-data-table';
import Pagination from 'sinoui-components/Pagination';

/**
 * 分页状态hook
 */
function usePagination(
  defaultCurrentPage: number = 0,
  defaultPageSize: number = 10,
): [number, number, (pageNo: number, pageSize: number) => void] {
  const [currentPage, setCurrentPage] = useState(defaultCurrentPage);
  const [pageSize, setPageSize] = useState(defaultPageSize);

  const update = (pageNo: number, newPageSize: number) => {
    setCurrentPage(pageNo);
    setPageSize(newPageSize);
  };

  return [currentPage, pageSize, update];
}

/**
 * 获取分页列表
 *
 * @param items 列表
 * @param currentPage 当前页
 * @param pageSize 页大小
 */
function usePaginationList<T>(
  items: T[],
  currentPage: number,
  pageSize: number,
) {
  const data = useMemo(
    () => items.slice(currentPage * pageSize, (currentPage + 1) * pageSize),
    [items, pageSize, currentPage],
  );

  return data;
}

function Demo() {
  const editingList = useEditingList('/api/pagination-show-demo');
  const [currentPage, pageSize, update] = usePagination();
  const data = usePaginationList(editingList.items, currentPage, pageSize);

  return (
    <div>
      <EditableDataTable
        data={data}
        idPropertyName={editingList.idPropertyName}
      >
        <TableColumn title="id" name="id" />
        <TableColumn title="标题" name="title" />
      </EditableDataTable>
      <Pagination
        total={editingList.items.length}
        currentPage={currentPage}
        pageSize={pageSize}
        onChange={(pageNo, newPageSize) => update(pageNo - 1, newPageSize)}
      />
    </div>
  );
}
```

## 新增数据

点击新增按钮时，在当前页新增一条数据。这个要求需要注意的是**在当前页**新增一条数据。所以我们应该按照下面的方式新增数据：

```tsx
editingList.add({}, currentPage * pageSize);
```

示例代码：

```tsx
import Button from 'sinoui-components/Button';

function Demo() {
  const handleAdd = () => {
    editingList.add({}, currentPage * pageSize);
  };

  return (
    <div>
      <Button raised onClick={handleAdd}>
        新增
      </Button>
    </div>
  );
}
```

## 编辑与删除数据

`editingList`提供的`edit`、`save`和`remove`方法都是根据数据在整个列表的索引位置进行操作的。所以我们在使用这些方法时，需要与分页状态相结合。

首先我们通过`TableColumn`添加一个操作列：在编辑状态时，有保存和删除按钮；在非编辑状态时，有编辑和删除按钮。

```tsx
<EditableDataTable>
  <TableColumn
    title="操作"
    render={(value, rowData, index, id, context) => (
      <>
        {context.editing ? <Button>保存</Button> : <Button>编辑</Button>}
        <Button color="danger">删除</Button>
      </>
    )}
  />
</EditableDataTable>
```

保存按钮的点击事件回调函数：

```tsx
<Button
  onClick={() => editingList.save(rowData, currentPage * pageSize + index)}
>
  保存
</Button>
```

重点是`currentPage * pageSize + index`。

编辑按钮：

```tsx
<Button onClick={() => editingList.edit(currentPage * pageSize + index)}>
  编辑
</Button>
```

删除按钮：

```tsx
<Button
  onClick={() => editingList.remove(rowData, currentPage * pageSize + index)}
>
  删除
</Button>
```

当然，别忘了将`editingList.editingRows`传给`EditableDataTable.editingRows`，并且定义单元格编辑器：

```tsx
<EditableDataTable editingRows={editingList.editingRows}>
  <TableColumn title="标题" name="title" editor="input" />
</EditableDataTable>
```

## 再次提炼状态管理

增加、删除、修改、编辑四个动作都与翻页有关系，我们可以将这四个方法提炼到一个自定义 hook：

```tsx
/**
 * 获取分页编辑列表的动作
 *
 * @param editingList 编辑列表
 * @param currentPage 当前页
 * @param pageSize 页大小
 */
function usePaginationEditingListActions<T>(
  editingList: any,
  currentPage: number,
  pageSize: number,
) {
  const add = useCallback(() => {
    editingList.add({}, currentPage * pageSize);
  }, [currentPage, editingList, pageSize]);

  const save = useCallback(
    (item: T, index: number) => {
      return editingList.save(item, currentPage * pageSize + index);
    },
    [currentPage, editingList, pageSize],
  );

  const edit = useCallback(
    (index: number) => {
      editingList.edit(currentPage * pageSize + index);
    },
    [currentPage, editingList, pageSize],
  );

  const remove = useCallback(
    (item: T, index: number) => {
      return editingList.remove(item, currentPage * pageSize + index);
    },
    [currentPage, editingList, pageSize],
  );

  return { add, save, edit, remove };
}
```

之后我们的代码就是这样子的：

```tsx
import React, { useState, useMemo, useCallback } from 'react';
import Pagination from 'sinoui-components/Pagination';
import Button from 'sinoui-components/Button';
import TextInput from 'sinoui-components/TextInput';
import EditableDataTable, { useEditingList, TableColumn } from '../src';

interface Article {
  id: string;
  title: string;
}

/**
 * 分页状态hook
 */
function usePagination(
  defaultCurrentPage: number = 0,
  defaultPageSize: number = 10,
): [number, number, (pageNo: number, pageSize: number) => void] {
  const [currentPage, setCurrentPage] = useState(defaultCurrentPage);
  const [pageSize, setPageSize] = useState(defaultPageSize);

  const update = (pageNo: number, newPageSize: number) => {
    setCurrentPage(pageNo);
    setPageSize(newPageSize);
  };

  return [currentPage, pageSize, update];
}

/**
 * 获取分页列表
 *
 * @param items 列表
 * @param currentPage 当前页
 * @param pageSize 页大小
 */
function usePaginationList<T>(
  items: T[],
  currentPage: number,
  pageSize: number,
) {
  const data = useMemo(
    () => items.slice(currentPage * pageSize, (currentPage + 1) * pageSize),
    [items, pageSize, currentPage],
  );

  return data;
}

/**
 * 获取分页编辑列表的动作
 *
 * @param editingList 编辑列表
 * @param currentPage 当前页
 * @param pageSize 页大小
 */
function usePaginationEditingListActions<T>(
  editingList: any,
  currentPage: number,
  pageSize: number,
) {
  const add = useCallback(() => {
    editingList.add({}, currentPage * pageSize);
  }, [currentPage, editingList, pageSize]);

  const save = useCallback(
    (item: T, index: number) => {
      return editingList.save(item, currentPage * pageSize + index);
    },
    [currentPage, editingList, pageSize],
  );

  const edit = useCallback(
    (index: number) => {
      editingList.edit(currentPage * pageSize + index);
    },
    [currentPage, editingList, pageSize],
  );

  const remove = useCallback(
    (item: T, index: number) => {
      return editingList.remove(item, currentPage * pageSize + index);
    },
    [currentPage, editingList, pageSize],
  );

  return { add, save, edit, remove };
}

function Demo() {
  const editingList = useEditingList<Partial<Article>>(
    '/api/pagination-show-demo',
    [],
  );
  const [currentPage, pageSize, update] = usePagination();
  const data = usePaginationList(editingList.items, currentPage, pageSize);
  const editingRows = usePaginationList(
    editingList.editingRows,
    currentPage,
    pageSize,
  );

  const { add, save, edit, remove } = usePaginationEditingListActions(
    editingList,
    currentPage,
    pageSize,
  );

  return (
    <div>
      <Button raised onClick={add}>
        新增
      </Button>
      <EditableDataTable
        data={data}
        editingRows={editingRows}
        idPropertyName={editingList.idPropertyName}
      >
        <TableColumn name="id" title="id" />
        <TableColumn name="title" title="标题" editor="input" />
        <TableColumn
          title="操作"
          name="id"
          render={(_value, item, index, _id, context) => (
            <>
              {context.editing ? (
                <Button autoWidth onClick={() => save(item, index)}>
                  保存
                </Button>
              ) : (
                <Button autoWidth onClick={() => edit(index)}>
                  编辑
                </Button>
              )}
              <Button
                autoWidth
                color="danger"
                onClick={() => remove(item, index)}
              >
                删除
              </Button>
            </>
          )}
        />
      </EditableDataTable>
      <Pagination
        pageSize={pageSize}
        total={editingList.items.length}
        currentPage={currentPage + 1}
        onChange={(pageNo, size) => update(pageNo - 1, size)}
      />
    </div>
  );
}
```

## 校验

在这个场景中，使用`EditableDataTable`内置的校验即可。

首先定义一下数据行的校验方法：

```tsx
function validate(rowData) {
  const errors: { [x: string]: string } = {};

  if (!rowData.title) {
    errors.title = '必填';
  }

  return errors;
}
```

然后将`validate`传递给`EditableDataTable`：

```tsx
<EditableDataTable validate={validate} />
```

到这一步，修改编辑器的值，就会调用`validate`方法校验数据是否有问题，这就是“实时校验”。

最后，调整保存方法，先校验数据，然后再保存数据：

```tsx
<Button
  autoWidth
  onClick={() => {
    if (!context.validate()) {
      alert('数据填写不完整');
    } else {
      save();
    }
  }}
>
  保存
</Button>
```

## 查询列表

`editingList.query(searechParams)`是用来查询的方法，可以在查询表单提交时调用这个方法，完成查询事宜。

举一个与某内部项目查询表单组件的组合，完成表格数据查询的功能。

例子 1：`SearchForm`是查询表单组件，`SearchButton`是查询按钮。点击查询按钮，查询表单会发出提交（submit）事件。

```tsx
<SearchForm onSubmit={editingList.query}>
  <SearchFormItem>
    <Label>标题</Label>
    <TextInput name="title" />
  </SearchFormItem>
  <SearchButton />
</SearchForm>
```

例子 2：`SearchFormState`是用来切换简单和复杂查询表单的组件，`advancedForm`和`simpleForm`两个属性分别用来指定复杂和查询表单。它有`onSubmit`属性，在查询表单的查询按钮被点击时，调用相对应的回调函数。

```tsx
<SearchFormState
  onSubmit={editingList.query}
  advancedForm={AdvancedSearchForm}
  simpleForm={SimpleSearchForm}
/>
```

## 选择

这个场景的选择因分页和一次性加载的要求，所以处理方式也会比[普通选择]()要复杂一些。`useEditingList`默认集成了选择行状态管理逻辑，但是需要二次处理才能适合当前这个场景。

首先，我们使用[RowTableColumn]()来渲染选择列：

```tsx
<RowSelectColumn
  startIndex={currentPage * pageSize}
  selectedRows={editingList.selectedRows}
  isAllSelected={editingList.isAllSelected}
  isContainsSelected={editingList.isContainsSelected}
  toggleAllSelected={editingList.toggleAllSelected}
  toggleRowSelected={editingList.toggleRowSelected}
/>
```

这个组件的三个属性需要做分页调整：

- `isAllSelected` - 判断是否全部选中。**更准确地说**，应该是判断当前页的数据是否全部选中。
- `isContainsSelected` - 判断是否包含选中数据。**更准确地说**，应该是判断当前页是否有选中的数据行。
- `toggleAllSelected` - 切换全选。**更准确地说**，应该是切换当前页所有数据的选中状态，要么全选，要么全部取消选中。

以上三个属性应该只跟当前页的数据相关，但是`editingList`提供的选择状态是与整个列表相关的，所以需要做二次处理。

首先，我们创建一个自定义 hook，名称为`usePaginationSelectedRows`:

```ts
function usePaginationSelectedRows(
  editingList: any,
  currentPage: number,
  pageSize: number,
) {
  const start = currentPage * pageSize;
  const end = Math.min(editingList.items.length, (currentPage + 1) * pageSize);

  // TODO: 下面的isAllSelected、isContainsSelected、toggleAllSelected的代码都放在这

  return {
    isAllSelected,
    isContainsSelected,
    toggleAllSelected,
  };
}
```

然后，我们来处理`isAllSelected`，它表示当前页是否全部选中，那么我们只需要拿到当前页所有行，然后看看每一行是否都在`editingList.selectedRows`中即可。

为了方便生成当前页所有行的索引数组，创建一个 range 方法：

```tsx
/**
 * 生成序列数组
 *
 * @param start 开始
 * @param end 结束
 */
function range(start: number, end: number) {
  return new Array(end - start).fill(null).map((_, idx) => start + idx);
}
```

`isAllSelected`的计算过程：

```tsx
/**
 * 是否全部选中
 */
const isAllSelected = useMemo(() => {
  return range(start, end).every(
    (idx) => editingList.selectedRows.indexOf(idx) !== -1,
  );
}, [currentPage, editingList.selectedRows, pageSize]);
```

接着处理`isContainsSelected`，它表示当前页是否有选中的数据行：

```tsx
/**
 * 是否包含选中
 */
const isContainsSelected = useMemo(() => {
  return range(start, end).some(
    (idx) => editingList.selectedRows.indexOf(idx) !== -1,
  );
}, [currentPage, editingList.selectedRows, pageSize]);
```

然后处理一下`toggleAllSelected`，它只能切换当前页行的选中状态：

```tsx
/**
 * 切换全选
 */
const toggleAllSelected = useCallback(() => {
  editingList.setRowsSelected(range(start, end), !isAllSelected);
}, [editingList, end, isAllSelected, start]);
```

最后，在`Demo`组件中使用`usePaginationSelectedRows`:

```tsx
function Demo() {
  // ...
  const paginationSelectedRows = usePaginationSelectedRows(
    editingList,
    currentPage,
    pageSize,
  );

  return (
    <EditableDataTable>
      <RowSelectColumn
        startIndex={currentPage * pageSize}
        selectedRows={editingList.selectedRows}
        isAllSelected={paginationSelectedRows.isAllSelected}
        isContainsSelected={paginationSelectedRows.isContainsSelected}
        toggleAllSelected={paginationSelectedRows.toggleAllSelected}
        toggleRowSelected={editingList.toggleRowSelected}
      />
    </EditableDataTable>
  );
}
```

## 删除选中数据

在`usePaginationSelectedRows`中添加一个`removeAllSelectedRows`方法：

```tsx
function usePaginationSelectedRows() {
  /**
   * 删除所有选中的数据
   */
  const removeAllSelectedRows = async () => {
    const rows = editingList.items
      .map((item, idx) => [item, idx])
      .filter((_data, index) => editingList.selectedRows.includes(index));
    await editingList.remove(rows);
  };

  return {
    // ...
    removeAllSelectedRows,
  };
}
```

将`paginationSelectedRows.removeAllSelectedRows`方法绑定到删除按钮的点击事件上即可。
